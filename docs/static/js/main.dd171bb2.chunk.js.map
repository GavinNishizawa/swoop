{"version":3,"sources":["assets/swoop.png","Point.js","Draw.js","Pen.js","Colors.js","Circle.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","Point","x","y","this","draw","ctx","width","height","points","getFrag","balls","deltas","i","length","push","currentPoints","map","p","realLength","updatePoints","pts","start","newPts","lastPoint","counter","interval","setInterval","ind","newBouncePoints","newPoints","cur","xvalue","quotient","Math","trunc","reflectPointX","reflectPointY","newpointer","bounce","clearInterval","clearRect","lineWidth","beginPath","moveTo","lineTo","forEach","ball","j","checkPoint","stroke","fillStyle","color","arc","point","radius","PI","fill","drawLoop","time","Pen","xs","ys","event","clientX","clientY","pointsLength","returnArray","index","Circle","pointX","pointY","point1X","point1Y","sqrt","pow","floor","random","colorNum","Colors","App","props","pen","onStart","e","preventDefault","onMove","onStop","canvasEl","document","getElementById","getContext","canvasPos","getBoundingClientRect","len","getFragment","makeCircles","testcircle1","reset","addEventListener","passive","className","href","rel","src","logo","alt","type","onClick","id","onPointerDown","onPointerMove","onPointerUp","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"qFAAAA,EAAOC,QAAU,IAA0B,mC,sNCC9BC,EACX,WAAYC,EAAGC,GAAI,oBACjBC,KAAKF,EAAIA,EACTE,KAAKD,EAAIA,GCDN,SAASE,EAAKC,EAAKC,EAAOC,EAAQC,EAAQC,EAASC,GAGxD,IADA,IAAIC,EAAS,GACLC,EAAI,EAAGA,EAAIJ,EAAOK,OAAQD,IAChCD,EAAOG,KAAM,IAAId,EACfQ,EAAOI,GAAGX,EAAIO,EAAO,GAAGP,EACxBO,EAAOI,GAAGV,EAAIM,EAAO,GAAGN,IAI5B,IAAIa,EAAgBP,EAAOQ,KAAI,SAACC,GAAD,OAAO,IAAIjB,EAAMiB,EAAEhB,EAAGgB,EAAEf,MACnDgB,EAAaH,EAAcF,OAC3BM,EAAe,SAACC,GAGlB,IAHoC,IAAbC,EAAY,uDAAN,EACzBC,EAAS,GAEJV,EAAI,EAAGA,EAAIM,EAAYN,IAC9BU,EAAOR,KAAKM,EAAIR,EAAES,IAGpB,IADA,IAAIE,EAAYH,EAAIC,EAAQH,EAAa,GAChCN,EAAI,EAAGA,EAAIM,EAAYN,IAC9BU,EAAOR,KAAM,IAAId,EACfuB,EAAUtB,EAAIU,EAAOC,GAAGX,EACxBsB,EAAUrB,EAAIS,EAAOC,GAAGV,IAG5B,OAAOoB,GAETP,EAAgBI,EAAaJ,GAC7B,IAEIS,EAAU,EACVC,EAAWC,aAAY,WAEzB,IAGIC,EAAMH,EAAUN,EAMhBU,EA4CD,SAAgBpB,EAAQF,EAAOC,GACpC,IAAIsB,EAAYrB,EAAOQ,KAAI,SAACC,GAAD,OAxB7B,SAAuBa,EAAKxB,GAC1B,IAAIyB,EAASD,EAAI7B,EAAIK,EACjB0B,EAAWC,KAAKC,MAAMJ,EAAI7B,EAAEK,GAGhC,OAAG0B,GAFgB,EAGV,KAEA,IAAIhC,EADHgC,EAAW,IAAM,EACRD,EAEAzB,EAAQyB,EAFAD,EAAI5B,GAgBGiC,CAAclB,EAAGX,MACnDuB,EAAYA,EAAUb,KAAI,SAACC,GAAD,OAV5B,SAAuBa,EAAKvB,GAC1B,OAAU,MAAPuB,GAAeA,EAAI5B,EAAIK,GAAUuB,EAAI5B,EAAI,EACnC,KAEA4B,EAMwBM,CAAcnB,EAAGV,MAGlD,IADA,IAAI8B,EAAa,GACRzB,EAAI,EAAGA,EAAIiB,EAAUhB,OAAQD,IACjB,MAAhBiB,EAAUjB,IACXyB,EAAWvB,KAAKe,EAAUjB,IAG9B,OAAOyB,EAtDiBC,CAHN7B,EAAQkB,EANJT,EAAW,EAMaH,GAGJT,EAAOC,GAGjB,IAA3BqB,EAAgBf,OACjB0B,cAAcd,GAqDb,SAAkBpB,EAAKG,EAAQE,GACpCL,EAAImC,UAAU,EAAE,EAAE,KAAK,KAGvBnC,EAAIoC,UAAY,EAChBpC,EAAIqC,YACJrC,EAAIsC,OAAOnC,EAAO,GAAGP,EAAGO,EAAO,GAAGN,GAClC,IAP0C,iBAQxC,IAAIe,EAAIT,EAAOI,GACfP,EAAIuC,OAAO3B,EAAEhB,EAAGgB,EAAEf,GACdQ,GACFA,EAAMmC,SAAQ,SAACC,EAAMC,GACfD,EAAKE,WAAW/B,WACXP,EAAMqC,OANZnC,EAAI,EAAGA,EAAIJ,EAAOK,OAAQD,IAAM,IAWzCP,EAAI4C,SAGAvC,GACFA,EAAMmC,SAAQ,SAAAC,GACZzC,EAAI6C,UAAYJ,EAAKK,MACrB9C,EAAIqC,YACJrC,EAAI+C,IAAIN,EAAKO,MAAMpD,EAAG6C,EAAKO,MAAMnD,EAAG4C,EAAKQ,OAAQ,EAAG,EAAIrB,KAAKsB,IAC7DlD,EAAImD,UA5EJC,CAASpD,EAAKuB,EAAiBlB,GAI7BiB,IAAQT,EAAW,IACrBH,EAAgBI,EAAaJ,EAAeG,IAG9CM,MACCkC,IAEH,OAAOjC,EC9DF,IAAMkC,EAAb,WACE,aAAe,oBACbxD,KAAKyD,GAAK,GACVzD,KAAK0D,GAAK,GAHd,oDAMUC,GACN,IAAI7D,EAAI6D,EAAMC,QACV7D,EAAI4D,EAAME,QACd7D,KAAKyD,GAAK,CAAC3D,GACXE,KAAK0D,GAAK,CAAC3D,KAVf,6BAaS4D,GACL,IAAI7D,EAAK6D,EAAMC,QACX7D,EAAK4D,EAAME,QAGf7D,KAAKyD,GAAG9C,KAAKb,GACbE,KAAK0D,GAAG/C,KAAKZ,KAnBjB,kCAwBcsB,EAASX,EAAQL,GAG3B,IAFA,IAAIyD,EAAezD,EAAOK,OACtBqD,EAAc,GACTtD,EAAIY,EAASZ,EAAIY,EAAUX,EAAQD,IAAI,CAC5C,IAAIuD,EAAQvD,EACRsD,EAAYrD,OAASA,IACjBD,GAAKqD,IACLE,EAAQvD,EAAIqD,GAGhBC,EAAYpD,KAAKN,EAAO2D,KAGhC,OAAOD,MArCX,KCKe,EALO,UAKP,EAJK,UAIL,EAHM,UAGN,EAFK,UCAPE,EAAb,WACI,WAAYf,EAAOC,EAAQH,GAAQ,oBACjChD,KAAKkD,MAAQA,EACblD,KAAKmD,OAASA,EACdnD,KAAKgD,MAAQA,EAJnB,uDAOeE,GACP,IAAIgB,EAASlE,KAAKkD,MAAMpD,EACpBqE,EAASnE,KAAKkD,MAAMnD,EACpBoD,EAASnD,KAAKmD,OAEdiB,EAAUlB,EAAMpD,EAChBuE,EAAUnB,EAAMnD,EAIpB,QAFe+B,KAAKwC,KAAKxC,KAAKyC,IAAIH,EAAUF,EAAQ,GAAKpC,KAAKyC,IAAIF,EAAUF,EAAQ,IAErEhB,MAjBvB,mCAyBuBhD,EAAOC,GAEtB,IAAI+C,EAASrB,KAAK0C,MAAO1C,KAAK2C,SAAWrE,EAAO,GAAM,IAElD8D,EAASpC,KAAK0C,MAAM1C,KAAK2C,UAAYtE,EAAQ,EAAEgD,GAAUA,GACzDgB,EAASrC,KAAK0C,MAAM1C,KAAK2C,UAAYrE,EAAS,EAAE+C,GAAUA,GAE1DuB,EAAW5C,KAAK0C,MAAsB,EAAhB1C,KAAK2C,UAE3BzB,EADS,CAAC2B,EAAaA,EAAeA,EAAcA,GACrCD,GAInB,OAFkB,IAAIT,EADJ,IAAIpE,EAAMqE,EAAQC,GACMhB,EAAQH,OApC1D,KCwHe4B,E,YAhHb,WAAYC,GAAQ,IAAD,8BACjB,4CAAMA,KAEDC,IAAM,IAAItB,EAMf,EAAKrD,MAAQ,KACb,EAAKC,OAAS,IAEd,EAAKG,MAAQ,GACb,EAAKe,SAAW,KAYhB,EAAKyD,QAAU,SAAAC,GACbA,EAAEC,iBACF,EAAKH,IAAIC,QAAQC,IAEnB,EAAKE,OAAS,SAAAF,GACZA,EAAEC,iBACF,EAAKH,IAAII,OAAOF,IAElB,EAAKG,OAAS,WACR,EAAK7D,WAEPc,cAAc,EAAKd,UACnB,EAAKA,SAAW,MAElB,IAAI8D,EAAWC,SAASC,eAAe,UACvC,GAAGF,EAASG,WAAW,CAQrB,IAPA,IAAIrF,EAAMkF,EAASG,WAAW,MAC1BC,EAAYJ,EAASK,wBAFJ,EAGN,EAAKX,IAAfrB,EAHgB,EAGhBA,GAAIC,EAHY,EAGZA,GACLgC,EAAMjC,EAAG/C,OAASgD,EAAGhD,OAAS+C,EAAG/C,OAASgD,EAAGhD,OAC7CO,EAAM,GAGFR,EAAI,EAAGA,EAAIiF,EAAKjF,IACtBQ,EAAIN,KAAK,IAAId,GAAW4D,EAAGhD,GAHR+E,EAAU1F,GAAK,EAAKK,MAAQqF,EAAUrF,OAGpBuD,EAAGjD,GAFrB+E,EAAUzF,GAAK,EAAKK,OAASoF,EAAUpF,SAI5D,EAAKkB,SAAWrB,EACdC,EACAkF,EAASjF,MACTiF,EAAShF,OACTa,EACA,EAAK6D,IAAIa,YACT,EAAKpF,SAMX,EAAKqF,YAAc,WACjB,EAAKrF,MAAQ,GACb,IAAK,IAAIE,EAAI,EAAGA,EAAI,GAAIA,IAAI,CAC1B,IAAIoF,EAAc5B,EAAO2B,YAAY,EAAKzF,MAAO,EAAKC,QACtD,EAAKG,MAAMI,KAAKkF,KAGpB,EAAKC,MAAQ,WACP,EAAKxE,WAEPc,cAAc,EAAKd,UACnB,EAAKA,SAAW,MAElB,EAAKsE,eA5EU,E,iFAgFjB5F,KAAK4F,cAELP,SAASU,iBAAiB,aAAa,SAAAf,GAAC,OAAIA,EAAEC,mBAAkB,CAAEe,SAAS,M,+BAI3E,OACE,yBAAKC,UAAU,OACb,4BAAQA,UAAU,cAClB,0BAAMC,KAAK,8EAA8EC,IAAI,eAC3F,yBAAKF,UAAU,QACb,yBAAKA,UAAU,WAAWG,IAAKC,IAAMC,IAAI,eACzC,uBAAGL,UAAU,SACX,0BAAMA,UAAU,cAAhB,wCAGA,6BAJF,2DAQF,4BAAQM,KAAK,SAASC,QAASxG,KAAK8F,OAApC,SACA,4BAAQW,GAAG,SAAStG,MAAOH,KAAKG,MAAOC,OAAQJ,KAAKI,OAClDsG,cAAe1G,KAAK+E,QACpB4B,cAAe3G,KAAKkF,OACpB0B,YAAa5G,KAAKmF,e,GAzGZ0B,IAAMC,WCCJC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAAShC,SAASC,eAAe,SD2H3C,kBAAmBgC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.dd171bb2.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/swoop.a31528de.png\";","\nexport class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}","\nimport { Point } from './Point';\n\nexport function draw(ctx, width, height, points, getFrag, balls){\n\n  let deltas = [];\n  for(let i = 0; i < points.length; i++) {\n    deltas.push( new Point(\n      points[i].x - points[0].x,\n      points[i].y - points[0].y,\n    ));\n  }\n\n  let currentPoints = points.map((p) => new Point(p.x, p.y));\n  let realLength = currentPoints.length;\n  let updatePoints = (pts, start=0) => {\n    let newPts = [];\n\n    for (let i = 0; i < realLength; i++) {\n      newPts.push(pts[i+start]);\n    }\n    let lastPoint = pts[start + realLength - 1];\n    for (let i = 0; i < realLength; i++) {\n      newPts.push( new Point(\n        lastPoint.x + deltas[i].x,\n        lastPoint.y + deltas[i].y,\n      ));\n    }\n    return newPts;\n  }\n  currentPoints = updatePoints(currentPoints);\n  let time = 1000;\n  let steps = 40;\n  let counter = 0;\n  let interval = setInterval(() => {\n    // Draw 1/3 of it at a time\n    let segmentLength = realLength/3;\n\n    // What index to start segment at\n    let ind = counter % realLength;\n\n    // Get the fragment to draw\n    let ptsToDraw = getFrag(ind, segmentLength, currentPoints);\n\n    // Bounce points if necessary\n    let newBouncePoints = bounce(ptsToDraw, width, height);\n\n    // If outside stop\n    if(newBouncePoints.length === 0){\n      clearInterval(interval);\n    } else {\n      // Draw the points\n      drawLoop(ctx, newBouncePoints, balls);\n    }\n\n    // If last segment, update points\n    if (ind === realLength-1) {\n      currentPoints = updatePoints(currentPoints, realLength);\n    }\n    // Move to next segment\n    counter++;\n  }, time/steps);\n\n  return interval;\n}\n\nfunction reflectPointX(cur, width){\n  var xvalue = cur.x % width;\n  var quotient = Math.trunc(cur.x/width);\n  var max_quotient = 3;\n\n  if(quotient >= max_quotient){\n    return null;\n  }else if (quotient % 2 === 0) {\n    return new Point(xvalue, cur.y);\n  }else{\n    return new Point(width - xvalue, cur.y);\n  }\n\n}\n\nfunction reflectPointY(cur, height){\n  if(cur == null || cur.y > height || cur.y < 0){\n    return null;\n  }else{\n    return cur;\n  }\n}\n\nexport function bounce(points, width, height){\n  let newPoints = points.map((p) => reflectPointX(p, width));\n  newPoints = newPoints.map((p) => reflectPointY(p, height));\n\n  let newpointer = [];\n  for (var i = 0; i < newPoints.length; i++) {\n    if(newPoints[i] != null){\n      newpointer.push(newPoints[i]);\n    }\n  }\n  return newpointer;\n}\n\nexport function drawLoop(ctx, points, balls){\n  ctx.clearRect(0,0,1500,600);\n\n  // Draw line\n  ctx.lineWidth = 3;\n  ctx.beginPath();\n  ctx.moveTo(points[0].x, points[0].y);\n  for (var i = 0; i < points.length; i++) {\n    let p = points[i];\n    ctx.lineTo(p.x, p.y);\n    if (balls) {\n      balls.forEach((ball, j) => {\n        if (ball.checkPoint(p)) {\n          delete balls[j];\n        }\n      })\n    }\n  }\n  ctx.stroke();\n\n  // Draw balls\n  if (balls) {\n    balls.forEach(ball => {\n      ctx.fillStyle = ball.color;\n      ctx.beginPath();\n      ctx.arc(ball.point.x, ball.point.y, ball.radius, 0, 2 * Math.PI);\n      ctx.fill();\n    })\n  }\n\n}\n","\nexport class Pen {\n  constructor() {\n    this.xs = [];\n    this.ys = [];\n  }\n\n  onStart(event) {\n    let x = event.clientX;\n    let y = event.clientY;\n    this.xs = [x];\n    this.ys = [y];\n  }\n\n  onMove(event) {\n    let x =  event.clientX;\n    let y =  event.clientY;\n    // console.log(`move: ${x},${y}`)\n\n    this.xs.push(x);\n    this.ys.push(y);\n  }\n\n  // switch to new declaration\n  // getFragment(counter, length, points) {\n  getFragment(counter, length, points) {\n    let pointsLength = points.length;\n    let returnArray = [];\n    for (let i = counter; i < counter + length; i++){\n        var index = i;\n        if (returnArray.length < length){\n            if (i >= pointsLength){\n                index = i % pointsLength;\n            }\n            // console.log(\"index: \" + index);\n            returnArray.push(points[index]);\n        }\n    }\n    return returnArray;\n  }\n}\n","\nexport const orange = \"#F36E3E\";\nexport const pink = \"#EE5E74\";\nexport const green = \"#98CA4E\";\nexport const blue = \"#1FA8C3\";\n\nexport default {\n    orange,\n    pink,\n    green,\n    blue,\n};","\nimport {Point} from './Point.js';\nimport Colors from './Colors.js';\n\nexport class Circle {\n    constructor(point, radius, color) {\n      this.point = point;\n      this.radius = radius;\n      this.color = color;\n    }\n\n    checkPoint(point){\n        let pointX = this.point.x;\n        let pointY = this.point.y;\n        let radius = this.radius;\n\n        let point1X = point.x;\n        let point1Y = point.y;\n\n        let distance = Math.sqrt(Math.pow(point1X - pointX, 2) + Math.pow(point1Y - pointY, 2));\n\n        if (distance > radius){\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n\n    static makeCircles(width, height){\n\n        let radius = Math.floor((Math.random() * height/12) + 10);\n\n        let pointX = Math.floor(Math.random() * (width - 2*radius) + radius);\n        let pointY = Math.floor(Math.random() * (height - 2*radius) + radius);\n\n        let colorNum = Math.floor(Math.random() * 4);\n        let colors = [Colors.blue, Colors.orange, Colors.green, Colors.pink];\n        let color = colors[colorNum];\n        let circlePoint = new Point(pointX, pointY);\n        let finalCircle = new Circle(circlePoint, radius, color);\n\n        return finalCircle;\n\n    }\n\n}\n","import React from 'react';\n// import logo from './logo.svg';\nimport './App.css';\n// import TestComponent from './TestComponent.bs';\nimport logo from './assets/swoop.png';\nimport { draw } from './Draw.js';\nimport { Pen } from './Pen';\nimport { Point } from './Point';\nimport { Circle } from './Circle'\n// import Colors from './Colors';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.pen = new Pen();\n    // let points = [10,20,30,40,50]\n    //   .map(v => new Point(v, v));\n    // for(let i = 0; i < 2*points.length; i++) {\n    //   console.log(this.pen.getFragment(i, 3, points));\n    // }\n    this.width = 1200;\n    this.height = 600;\n\n    this.balls = [];\n    this.interval = null;\n\n    // let testpoint = new Point(130,130);\n    // let testpointin = new Point(1, 1);\n    // let testpointout = new Point(9, 0);\n    // let testpointon = new Point(7, 3);\n    // let testcircle = new Circle(testpoint, 30, Colors.blue);\n    // console.log(testcircle);\n    // console.log(testcircle.checkPoint(testpointin));\n    // console.log(testcircle.checkPoint(testpointout));\n    // console.log(testcircle.checkPoint(testpointon));\n\n    this.onStart = e => {\n      e.preventDefault();\n      this.pen.onStart(e);\n    };\n    this.onMove = e => {\n      e.preventDefault();\n      this.pen.onMove(e);\n    };\n    this.onStop = () => {\n      if (this.interval) {\n        // Clear old interval\n        clearInterval(this.interval);\n        this.interval = null;\n      }\n      let canvasEl = document.getElementById('canvas');\n      if(canvasEl.getContext){\n        let ctx = canvasEl.getContext('2d');\n        let canvasPos = canvasEl.getBoundingClientRect();\n        let {xs, ys} = this.pen;\n        let len = xs.length < ys.length ? xs.length : ys.length;\n        let pts = [];\n        let fixX = x => (x - canvasPos.x) * this.width / canvasPos.width;\n        let fixY = y => (y - canvasPos.y) * this.height / canvasPos.height;\n        for(let i = 0; i < len; i++) {\n          pts.push(new Point(fixX(xs[i]), fixY(ys[i])));\n        }\n        this.interval = draw(\n          ctx,\n          canvasEl.width,\n          canvasEl.height,\n          pts,\n          this.pen.getFragment,\n          this.balls\n        );\n      }\n      // console.log(this.pen);\n    };\n\n    this.makeCircles = () => {\n      this.balls = [];\n      for (var i = 0; i < 20; i++){\n        let testcircle1 = Circle.makeCircles(this.width, this.height);\n        this.balls.push(testcircle1);\n      }\n    }\n    this.reset = () => {\n      if (this.interval) {\n        // Clear old interval\n        clearInterval(this.interval);\n        this.interval = null;\n      }\n      this.makeCircles();\n    }\n  }\n  componentDidMount() {\n    this.makeCircles();\n    // Prevent scrolling on mobile when trying to draw\n    document.addEventListener(\"touchmove\", e => e.preventDefault(), { passive: false });\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n        <link href=\"https://fonts.googleapis.com/css?family=Roboto:400,500,700,900&display=swap\" rel=\"stylesheet\"/>\n          <div className=\"logo\">\n            <img className=\"App-logo\" src={logo} alt=\"swoop-logo\"/>\n            <p className=\"rules\">\n              <span className=\"relaxation\">\n                Promoting relaxation through colors!\n              </span>\n              <br />\n              Rules are simple. Draw a line and see it pop the dots.\n            </p>\n          </div>\n          <button type=\"button\" onClick={this.reset}>Reset</button>\n          <canvas id='canvas' width={this.width} height={this.height}\n            onPointerDown={this.onStart}\n            onPointerMove={this.onMove}\n            onPointerUp={this.onStop}\n          />\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}